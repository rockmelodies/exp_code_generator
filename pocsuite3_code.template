from pocsuite3.api import Output, POCBase, logger, VUL_TYPE, POC_CATEGORY, OrderedDict, OptString
from pocsuite3.api import register_poc
from pocsuite3.api import requests
import random
import string

def get_filename(size=6, chars=string.ascii_lowercase + string.digits):
    return ''.join(random.choice(chars) for _ in range(size))

class ${CLASSNAME}(POCBase):
    # 非必填的字段，需保留字段名称，值为空
    vulID = '${VUL_ID}'  # 必填，poc id，保持不变即可，后端会自动填写
    version = '1.0'  # 必填，poc版本，从1开始
    author = ['360漏洞云']  # 必填，作者
    vulDate = '${VUL_DATE}'  # 必填，漏洞发布时间
    createDate = '${CREATEDATE}'  # 必填，poc创建时间
    updateDate = '${UPDATEDATE}'  # 必填，poc更新时间

    name = '${APP_NAME}_${VUL_NAME}_${VUL_NUM}'  # 必填，poc名称，格式 [app名称]_[漏洞名称]_[cve/cnvd号]
    CVE = '${CVE_NUM}'  # 非必填，cve号，大写
    CNVD = ''  # 非必填，cnvd号，大写
    vulType = VUL_TYPE.${VUL_TYPE}  # 必填，漏洞类型，参考 pocsuite3 VUL_TYPE的取值范围
    category = POC_CATEGORY.${POC_CATEGORY}  # 必填，漏洞分类，参考 pocsuite3 POC_CATEGORY的取值范围
    severity = '${SEVERITY}'  # 必填，严重等级，取值范围 Critical , High , Medium, Low
    reqAuth = ${REQAUTH}  # 必填，boolen值，该漏洞验证或利用是否需要先认证

    appName = '${APP_NAME}'  # 必填，该漏洞对应的应用名称
    fingerprintNames = ['${FINGERPRINT_NAMES}']  # 必填，当命中哪些指纹后，可使用该poc。列表中是指纹的名称
    app_main_port = ${APP_MAIN_PORT}  # 必填，该应用的默认配置端口，用于快速扫描模式，若无法确认可以写80
    appVersion = '${APPVERSION}'  # 必填，漏洞影响的版本号

    appPowerLink = 'https://www.oracle.com/'  # 非必填，应用厂商链接
    references = ['${REFERENCES}']  # 非必填，漏洞相关参考链接
    desc = '''${DESC}'''  # 必填，漏洞描述，需尽量详细，参考cnnvd的写法 [应用简介]，[漏洞简介]
    suggest = '''${SUGGEST}'''  # 必填，修复建议
    hasExp = ${HASEXP}  # 必填，boolen值，是否包含exp
    targets = '${TARGETS}'  # 必填，该Poc适用的目标，string类型 https://github.com/vulhub/vulhub/tree/master/weblogic/CVE-2017-10271
    suricata_rules = 'alert tcp any any -> any any (msg:"thinkphp_CNVD-2022-86535"; content:"${SURICATA_RULES}";sid:1;classtype:aes; metadata:aes_team_rules;)'  # 必填，suricata格式的检测规则

    def _options(self):
        o = OrderedDict()
        ## verify proxy feature  这三个参数是必须要有的，用于在目标无法出网的情况下的内网无回显漏洞验证，verify_send_url用于触发目标http请求，verify_check_url用于验证无回显漏洞，verify_proxy用于目标无法直连server的情况下走我们搭建的代理
        # o['verify_proxy'] = OptString('', description='对于无回显poc, 验证时curl要使用的socks5代理')
        # o['verify_send_url'] = OptString('', description='对于无回显poc, 验证时用于访问的url')
        # o['verify_check_url'] = OptString('', description='对于无回显poc, 验证时用于检查的url')
        ## verify proxy feature

        ${COMMAND}o['command'] = OptString('whoami', description='攻击时自定义命令')
        # o["server_ip"] = OptString("", description='rmi、ldap等服务器的ip地址，用于特定场景下的attack或verify')
        # o["server_port"] = OptString("", description='rmi、ldap等服务器的端口，用于特定场景下的attack或verify')
        ${FILE_PATH}o["file_path"] = OptString("", description='待上传文件的绝对路径，一般是webshell文件，用于文件上传的attack')
        return o

    def _verify(self):
        result = {}
        url= self.url.rstrip("/")
        payload_url = url + "${URI}"
        headers = ${HEADERS}
        payload_data = ${PAYLOAD_DATA}
        try:
            r = requests.${METHOD}(payload_url, payload_data, headers=headers)
            if r.status_code == 200 and "${KEYWORD}" in r.text:
                result['VerifyInfo'] = {}
                result['VerifyInfo']['URL'] = self.url
        except Exception as e:
            logger.error(f"connect target '{self.url} failed!'")
        return self.parse_output(result)

    def _attack(self):
        filename = get_filename()
        ${COMMAND}cmd = self.get_option('command')
        ${FILE_PATH}with open(self.get_option("file_path"), "r") as f:
            ${FILE_PATH}f = str(f.read())
            ${FILE_PATH}file_content = f
        result = {}
        url = self.url.rstrip("/")
        payload_url = url + f"${ATTACK_URI}"
        headers = ${HEADERS}
        payload_data = """${ATTACK_PAYLOAD_DATA}"""
        try:
            r = requests.${METHOD}(payload_url, payload_data, headers=headers)
            if r.status_code == 200:
                result['AttackInfo'] = {}
                result['AttackInfo']['URL'] = url
                ${FILE_PATH}result['AttackInfo']['FILE_URL'] = url + "/" + filename + ".php"
                ${COMMAND}result['AttackInfo']['Stdout'] = r.text
        except Exception as e:
            logger.error(f"connect target '{self.url} failed!'")
        return self.parse_output(result)

    def parse_output(self, result):
        output = Output(self)
        if result:
            output.success(result)
        else:
            output.fail('target is not vulnerable')
        return output


register_poc(${CLASSNAME})

